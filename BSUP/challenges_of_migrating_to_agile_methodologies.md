# Challenges of Migrating to Agile Methodologies

> [Challenges of migrating to agile methodologies](https://learnit.itu.dk/pluginfile.php/166159/course/section/88126/2005%20-%20Nerur%20-%20Challenges%20of%20migrating%20to%20agile%20methodologies.pdf)

Modern organizations need information systems that constantly evolve to meet their changing requirements.

The traditional, plan-driven software development methodologies lack the flexibility to dynamically adjust the development process.

This article emphasizes the difficulties of moving an organization from a plan-driven/sequential approach to agile.

Since plan-driven and agile are two opposing concepts, it will be very hard for an organization to go from one to another.

And also, it has organization-wide ramifications since it takes a cultural shift within the organization to convert to agile.

## The old approach

A rational engineering-based approach has dominated software development, grounded in the principle that **problems are fully specifiable and that an optimal and predictable solution exists for every problem**.

And so, extensive upfront planning is the basis for predicting, measuring and controlling problems and variations during the development life cycle. It is **process-centric**, guided by the belief that sources of variations are identifiable and may be eliminated by continually measuring and refining processes.

### Life cycle model

In the traditional approach, software development is guided by a life cycle model such as waterfall, spiral or some variation of those.

Such a model specifies the tasks to be performed and the desired outcomes of each phase (or step, as it is often called). Roles are then assigned to individuals who will perform these tasks.

These process models involve a great deal of documentation on top of just the code.

### Agile and unpredictability

Agile handles unpredictability by relying on people and their creativity, rather than on processes.

Short iterative cycles of development driven by product features, periods of reflection and introspection, collaborative decision making, incorporation of rapid feedback and change and continuous integration of code changes into the system under development is the agile way.

A project is broken down into sub-projects ("sprints" in Scrum), each of which involves planning, development, integration, testing and delivery.

Customers are active team members (in the sense that they can participate in some of the meanings).

**Collaborative decision making, involving stakeholders with diverse backgrounds and goals is thus a characteristic of agile development**.

The deliverable of each development cycle is working code that can be used by the customer.

**Agile methods discourage documentation beyond the code**. Thus, product knowledge becomes implicit, intuitively understood by the team.

## Traditional vs Agile chart

<table>
	<tr>
		<td></td>
		<td><strong>Traditional</strong></td>
		<td><strong>Agile</strong></td>
	</tr>
	<tr>
		<td><strong>Fundamental Assumptions</strong></td>
		<td>Systems are fully specifiable, predictable, and can be built through meticulous and extensive planning</td>
		<td>High-quality, adaptive software can be developed by small teams using the principles of continuous design improvement and testing based on rapid feedback and change.</td>
	</tr>
	<tr>
		<td><strong>Control</strong></td>
		<td>Process centric</td>
		<td>People centric</td>
	</tr>
	<tr>
		<td><strong>Management Style</strong></td>
		<td>Command-and-control</td>
		<td>Leadership-and-collaboration</td>
	</tr>
	<tr>
		<td><strong>Knowledge management</strong></td>
		<td>Explicit</td>
		<td>Implicit/Implied (understood without being openly expressed)</td>
	</tr>
	<tr>
		<td><strong>Role Assignment</strong></td>
		<td>Individual - favors specialization</td>
		<td>Self-organizing teams - encourages role interchangeability</td>
	</tr>
	<tr>
		<td><strong>Communication</strong></td>
		<td>Formal</td>
		<td>Informal</td>
	</tr>
	<tr>
		<td><strong>Customer's Role</strong></td>
		<td>Important</td>
		<td>Critical</td>
	</tr>
	<tr>
		<td><strong>Project Cycle</strong></td>
		<td>Guided by tasks or activities</td>
		<td>Guided by product features</td>
	</tr>
	<tr>
		<td><strong>Development Model</strong></td>
		<td>Life cycle model (Waterfall, Spiral, or some variation)</td>
		<td>The evolutionary-delivery model</td>
	</tr>
	<tr>
		<td><strong>Desired Organizational Form/Structure</strong></td>
		<td>Mechanistic (bureaucratic with high formalization)</td>
		<td>Organic (flexible and participative, encouraging cooperative social action)</td>
	</tr>
	<tr>
		<td><strong>Technology</strong></td>
		<td>No restriction</td>
		<td>Favors object-oriented technology</td>
	</tr>
</table>

## Making Agile work

For decades, organizations have pursed the goal of creating optimized and repeatable processes. They want stability and predictability. This is most likely driven by the traditional engineering approach to software development. But as we have come to see time and again, requirements change all the time, and the main reason for error in software development is the requirements themselves.

### Key issues to migrating from traditional to agile

It is hard to change the culture or mindsets within an organization. If the management style is directive and autocratic, people will most likely be motivated by individual rewards whereas a permissive democratic style, which agile very much requires (permissive in the sense that the organization holds only lists the requirements and its up to the team to fulfil them as they please and democratic in the sense that groups are self-organizing and making decisions on their own), will favor team rewards.

Also, the project manager's traditional role of planner and controller must be altered to that of a facilitator who directs and coordinates the collaborative efforts of those involved in development. This too will require changing that managers mind.

Also, in terms of going from people (resources) being assigned directly to tasks to a collaborative social process, programmers will be accustomed to solitary activities or working with a homogenous group of analysts and designers and have a hard time adjusting. It may be overwhelming to suddenly do shared learning, reflection workshops, pair-programming and collaborative decision-making.

#### Management and organizational issues

- Organizational culture
- Management style
- Organizational form
- Management of software development knowledge
- Reward systems

#### People

- Working effectively in a team
- High level of competence
- Customer relationships - commitment, knowledge, proximity, trust, respect

#### Process

- Change from process-centric to feature-driven, people-centric approach
- Short, iterative, test-driven development that emphasizes adaptability
- Managing large, scalable projects
- Selecting an appropriate agile method

#### Technology

- Appropriateness of existing technology and tools
- New skill sets - refactoring, configuration management.